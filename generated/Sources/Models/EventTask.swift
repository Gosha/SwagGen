//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class EventTask: APIModel {

    public var acceptQuestion: AcceptQuestion?

    public var addCoordinate: AddCoordinate?

    public var answerQuestion: AnswerQuestion?

    public var changeBooking: Booking?

    public var changeMessage: Message?

    public var changeQuestion: Question?

    public var closeErrand: Bool?

    public var createBooking: Booking?

    public var createMessage: Message?

    public var createQuestion: Question?

    public var denyQuestion: DenyQuestion?

    public var oneLocation: OneLocation?

    public var openBooking: String?

    public var openMessage: String?

    public var openQuestion: String?

    public var readMessage: String?

    public var seenLocation: Bool?

    public var selectBooking: SelectBooking?

    public var startLocation: Bool?

    public var stopLocation: Bool?

    public class AcceptQuestion: APIModel {

        public var questionId: String

        public var answer: AnswerType

        public var message: Message

        public init(questionId: String, answer: AnswerType, message: Message) {
            self.questionId = questionId
            self.answer = answer
            self.message = message
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            questionId = try container.decode("questionId")
            answer = try container.decode("answer")
            message = try container.decode("message")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(questionId, forKey: "questionId")
            try container.encode(answer, forKey: "answer")
            try container.encode(message, forKey: "message")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? AcceptQuestion else { return false }
          guard self.questionId == object.questionId else { return false }
          guard self.answer == object.answer else { return false }
          guard self.message == object.message else { return false }
          return true
        }

        public static func == (lhs: AcceptQuestion, rhs: AcceptQuestion) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class AddCoordinate: APIModel {

        public var coordinate: Coordinate

        public var timestamp: UTCTime

        public init(coordinate: Coordinate, timestamp: UTCTime) {
            self.coordinate = coordinate
            self.timestamp = timestamp
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            coordinate = try container.decode("coordinate")
            timestamp = try container.decode("timestamp")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(coordinate, forKey: "coordinate")
            try container.encode(timestamp, forKey: "timestamp")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? AddCoordinate else { return false }
          guard self.coordinate == object.coordinate else { return false }
          guard self.timestamp == object.timestamp else { return false }
          return true
        }

        public static func == (lhs: AddCoordinate, rhs: AddCoordinate) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class AnswerQuestion: APIModel {

        public var questionId: String

        public var answer: AnswerType

        public init(questionId: String, answer: AnswerType) {
            self.questionId = questionId
            self.answer = answer
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            questionId = try container.decode("questionId")
            answer = try container.decode("answer")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(questionId, forKey: "questionId")
            try container.encode(answer, forKey: "answer")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? AnswerQuestion else { return false }
          guard self.questionId == object.questionId else { return false }
          guard self.answer == object.answer else { return false }
          return true
        }

        public static func == (lhs: AnswerQuestion, rhs: AnswerQuestion) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class DenyQuestion: APIModel {

        public var questionId: String

        public var message: Message

        public init(questionId: String, message: Message) {
            self.questionId = questionId
            self.message = message
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            questionId = try container.decode("questionId")
            message = try container.decode("message")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(questionId, forKey: "questionId")
            try container.encode(message, forKey: "message")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? DenyQuestion else { return false }
          guard self.questionId == object.questionId else { return false }
          guard self.message == object.message else { return false }
          return true
        }

        public static func == (lhs: DenyQuestion, rhs: DenyQuestion) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class OneLocation: APIModel {

        public var coordinate: Coordinate

        public var timestamp: UTCTime

        public init(coordinate: Coordinate, timestamp: UTCTime) {
            self.coordinate = coordinate
            self.timestamp = timestamp
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            coordinate = try container.decode("coordinate")
            timestamp = try container.decode("timestamp")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(coordinate, forKey: "coordinate")
            try container.encode(timestamp, forKey: "timestamp")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? OneLocation else { return false }
          guard self.coordinate == object.coordinate else { return false }
          guard self.timestamp == object.timestamp else { return false }
          return true
        }

        public static func == (lhs: OneLocation, rhs: OneLocation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class SelectBooking: APIModel {

        public var bookingId: String

        public var times: [UTCTime]

        public init(bookingId: String, times: [UTCTime]) {
            self.bookingId = bookingId
            self.times = times
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            bookingId = try container.decode("bookingId")
            times = try container.decodeArray("times")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(bookingId, forKey: "bookingId")
            try container.encode(times, forKey: "times")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? SelectBooking else { return false }
          guard self.bookingId == object.bookingId else { return false }
          guard self.times == object.times else { return false }
          return true
        }

        public static func == (lhs: SelectBooking, rhs: SelectBooking) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(acceptQuestion: AcceptQuestion? = nil, addCoordinate: AddCoordinate? = nil, answerQuestion: AnswerQuestion? = nil, changeBooking: Booking? = nil, changeMessage: Message? = nil, changeQuestion: Question? = nil, closeErrand: Bool? = nil, createBooking: Booking? = nil, createMessage: Message? = nil, createQuestion: Question? = nil, denyQuestion: DenyQuestion? = nil, oneLocation: OneLocation? = nil, openBooking: String? = nil, openMessage: String? = nil, openQuestion: String? = nil, readMessage: String? = nil, seenLocation: Bool? = nil, selectBooking: SelectBooking? = nil, startLocation: Bool? = nil, stopLocation: Bool? = nil) {
        self.acceptQuestion = acceptQuestion
        self.addCoordinate = addCoordinate
        self.answerQuestion = answerQuestion
        self.changeBooking = changeBooking
        self.changeMessage = changeMessage
        self.changeQuestion = changeQuestion
        self.closeErrand = closeErrand
        self.createBooking = createBooking
        self.createMessage = createMessage
        self.createQuestion = createQuestion
        self.denyQuestion = denyQuestion
        self.oneLocation = oneLocation
        self.openBooking = openBooking
        self.openMessage = openMessage
        self.openQuestion = openQuestion
        self.readMessage = readMessage
        self.seenLocation = seenLocation
        self.selectBooking = selectBooking
        self.startLocation = startLocation
        self.stopLocation = stopLocation
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        acceptQuestion = try container.decodeIfPresent("AcceptQuestion")
        addCoordinate = try container.decodeIfPresent("AddCoordinate")
        answerQuestion = try container.decodeIfPresent("AnswerQuestion")
        changeBooking = try container.decodeIfPresent("ChangeBooking")
        changeMessage = try container.decodeIfPresent("ChangeMessage")
        changeQuestion = try container.decodeIfPresent("ChangeQuestion")
        closeErrand = try container.decodeIfPresent("CloseErrand")
        createBooking = try container.decodeIfPresent("CreateBooking")
        createMessage = try container.decodeIfPresent("CreateMessage")
        createQuestion = try container.decodeIfPresent("CreateQuestion")
        denyQuestion = try container.decodeIfPresent("DenyQuestion")
        oneLocation = try container.decodeIfPresent("OneLocation")
        openBooking = try container.decodeIfPresent("OpenBooking")
        openMessage = try container.decodeIfPresent("OpenMessage")
        openQuestion = try container.decodeIfPresent("OpenQuestion")
        readMessage = try container.decodeIfPresent("ReadMessage")
        seenLocation = try container.decodeIfPresent("SeenLocation")
        selectBooking = try container.decodeIfPresent("SelectBooking")
        startLocation = try container.decodeIfPresent("StartLocation")
        stopLocation = try container.decodeIfPresent("StopLocation")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(acceptQuestion, forKey: "AcceptQuestion")
        try container.encodeIfPresent(addCoordinate, forKey: "AddCoordinate")
        try container.encodeIfPresent(answerQuestion, forKey: "AnswerQuestion")
        try container.encodeIfPresent(changeBooking, forKey: "ChangeBooking")
        try container.encodeIfPresent(changeMessage, forKey: "ChangeMessage")
        try container.encodeIfPresent(changeQuestion, forKey: "ChangeQuestion")
        try container.encodeIfPresent(closeErrand, forKey: "CloseErrand")
        try container.encodeIfPresent(createBooking, forKey: "CreateBooking")
        try container.encodeIfPresent(createMessage, forKey: "CreateMessage")
        try container.encodeIfPresent(createQuestion, forKey: "CreateQuestion")
        try container.encodeIfPresent(denyQuestion, forKey: "DenyQuestion")
        try container.encodeIfPresent(oneLocation, forKey: "OneLocation")
        try container.encodeIfPresent(openBooking, forKey: "OpenBooking")
        try container.encodeIfPresent(openMessage, forKey: "OpenMessage")
        try container.encodeIfPresent(openQuestion, forKey: "OpenQuestion")
        try container.encodeIfPresent(readMessage, forKey: "ReadMessage")
        try container.encodeIfPresent(seenLocation, forKey: "SeenLocation")
        try container.encodeIfPresent(selectBooking, forKey: "SelectBooking")
        try container.encodeIfPresent(startLocation, forKey: "StartLocation")
        try container.encodeIfPresent(stopLocation, forKey: "StopLocation")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? EventTask else { return false }
      guard self.acceptQuestion == object.acceptQuestion else { return false }
      guard self.addCoordinate == object.addCoordinate else { return false }
      guard self.answerQuestion == object.answerQuestion else { return false }
      guard self.changeBooking == object.changeBooking else { return false }
      guard self.changeMessage == object.changeMessage else { return false }
      guard self.changeQuestion == object.changeQuestion else { return false }
      guard self.closeErrand == object.closeErrand else { return false }
      guard self.createBooking == object.createBooking else { return false }
      guard self.createMessage == object.createMessage else { return false }
      guard self.createQuestion == object.createQuestion else { return false }
      guard self.denyQuestion == object.denyQuestion else { return false }
      guard self.oneLocation == object.oneLocation else { return false }
      guard self.openBooking == object.openBooking else { return false }
      guard self.openMessage == object.openMessage else { return false }
      guard self.openQuestion == object.openQuestion else { return false }
      guard self.readMessage == object.readMessage else { return false }
      guard self.seenLocation == object.seenLocation else { return false }
      guard self.selectBooking == object.selectBooking else { return false }
      guard self.startLocation == object.startLocation else { return false }
      guard self.stopLocation == object.stopLocation else { return false }
      return true
    }

    public static func == (lhs: EventTask, rhs: EventTask) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
